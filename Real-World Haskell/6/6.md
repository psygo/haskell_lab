# Typeclasses

- Without typeclasses, such as `==`: we have to use a function with a differentname for every different type that we want to be able to compare.

- Typeclasses define a set of functions that can have different implementations dependingon the type of data they are given. Typeclasses may look like the objects of object-oriented programming, but they are truly quite different

- While it is possible to build sophisticated parsers using the Read type-class, many people find it easier to do so using Parsec, and rely onRead only for simpler tasks.

- Note that there are also many more numeric types available for specific purposes such as interfacing to C.

- Notice that the sort order for Color was based on the order in which the constructorswere defined.

- if  you  defined  a  typedata MyType = MyType (Int -> Bool), the compiler will not be able to derive an instanceof Show because it doesnâ€™t know how to render a function. We will get a compilationerror in such a situation.

- Relaxing a rule from GHC: `{-# LANGUAGE TypeSynonymInstances #-}`.

- Normally, we cannot write an instance of a typeclass for a specialized version of apolymorphic type. The [Char] type is the polymorphic type [a] specialized to the typeChar. We are thus prohibited from declaring [Char] to be an instance of a typeclass.This is highly inconvenient, since strings are ubiquitous in real code.
    - `TypeSynonymInstances`, `OverlappingInstances`

- The newtype keyword exists to give an existing type a new identity, and it has morerestrictions on its uses than the data keyword. Specifically, a newtype can have only onevalue constructor, which must have exactly one field.