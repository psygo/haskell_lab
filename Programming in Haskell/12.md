# Monads and More

- Functors
- Applicatives
- Monads

## Functors

More generally, the idea of mapping a function over each element of a datastructure isnâ€™t specific to the type of lists, but can be abstracted further to a widerange of parameterised types. The class of types that support such a mappingfunction are called functors. In Haskell, this concept is captured by the following class declaration in the standard prelude:

```hs
class Functor f where
   fmap :: (a -> b) -> f a -> f b
```

That is, for a parameterised type f to be an instance of the class Functor, it must support a function fmap of the specified type. The intuition is that fmaptakes a function of type a -> b and a structure of type f a whose elements havetype a, and applies the function to each such element to give a structure of typef b whose elements now have type b. The fact that f must be a parameterisedtype, that is, a type that takes another type as a parameter, is determinedautomatically during type inference by virtue of the application of f to the types a and b in the specified type for fmap in the class declaration.

### Examples

As we would expect, the type of lists can be made into a functor by simply
defining fmap to be the function map:

```hs
instance Functor [] where
   -- fmap :: (a -> b) -> [a] -> [b]
   fmap = map

instance Functor Maybe where
   -- fmap :: (a -> b) -> Maybe a -> Maybe b
   fmap _ Nothing = Nothing
   fmap g (Just x) = Just (g x)
```

However, not all instances fit this pattern. For example,
the IO type is not a container type in the normal sense of the term because its
values represent input/output actions whose internal structure we do not have
access to, but it can readily be made into a functor:

```hs
instance Functor IO where
   -- fmap :: (a -> b) -> IO a -> IO b
   fmap g mx = do {x <- mx; return (g x)}
```

**The main benefits**:

- The function fmap can be used to process the elements of any structure that is functorial. That is, we can use the same name for functions that are essentially the same, rather than having to invent a separate name for each instance.
- We can define generic functions that can be used with any functor. For example, our earlier function that increments each integer in a list can be generalised to any functorial type by simply using fmap rather than map:

```hs
inc :: Functor f => f Int -> f Int
inc = fmap (+1)

> inc (Just 1)
Just 2

> inc [1,2,3,4,5]
[2,3,4,5,6]

> inc (Node (Leaf 1) (Leaf 2))
Node (Leaf 2) (Leaf 3)
```

## Functor Laws

The 2 laws:

```hs
fmap id      = id
fmap (g . h) = fmap g . fmap h
```

Note,however, that the two occurrences of id in this equation have different types: on the left-hand side id has type a -> a and hence fmap id has type f a -> f a,which means that the id on the right-hand side must also have type f a -> f a in order for the equation to be well-typed.

We will see how to formally prove such properties when we consider tech-niques for reasoning about programs in chapter 16. In fact, for any parameterisedtype in Haskell, there is at most one function fmap that satisfies the requiredlaws. That is, if it is possible to make a given parameterised type into a functor,there is only one way to achieve this. Hence, the instances that we defined for lists, Maybe, Tree and IO were all uniquely determined.

## Applicatives

Suppose now that we wish to generalise this idea to allow functions with any
number of arguments to be mapped, rather than being restricted to functions
with a single argument.

```hs
fmap0 :: a -> f a
fmap1 :: (a -> b) -> f a -> f b
fmap2 :: (a -> b -> c) -> f a -> f b -> f c
fmap3 :: (a -> b -> c -> d) -> f a -> f b -> f c -> f d
```

In fact, using the idea of currying, it turns out that a version of fmap for functions with any desired number of arguments can be constructed in terms of two basic functions with the following types:

```hs
pure :: a -> f a

(<*>) :: f (a -> b) -> f a -> f b

g <*> x <*> y <*> z

-- applicative style:
pure g <*> x1 <*> x2 <*> ... <*> xn
```

The class of functors that support pure and <*> functions are called applicative functors, or applicatives for short. In Haskell, this concept is captured by the following built-in class declaration:

```hs
class Functor f => Applicative f where
   pure :: a -> f a
   (<*>) :: f (a -> b) -> f a -> f b

instance Applicative Maybe where
   -- pure :: a -> Maybe a
   pure = Just

   -- (<*>) :: Maybe (a -> b) -> Maybe a -> Maybe b
   Nothing <*> _ = Nothing
   (Just g) <*> mx = fmap g mx
```

**The one line of code that justifies all this gymnastics**:

```hs
pure (+) <*> Nothing <*> Just 2
Nothing
```

In this manner, the applicative style for Maybe supports a form of exceptional programming in which we can apply pure functions to arguments that may fail without the need to manage the propagation of failure ourselves, as this is taken care of automatically by the applicative machinery.

In summary, the applicative style for lists supports a form of non-deterministic programming in which we can apply pure functions to multi-valued arguments without the need to manage the selection of values or the propagation of failure, as this is taken care of by the applicative machinery.

```hs
instance Applicative IO where
   -- pure :: a -> IO a
   pure = return

   -- (<*>) :: IO (a -> b) -> IO a -> IO b
   mg <*> mx = do {g <- mg; x <- mx; return (g x)}


getChars :: Int -> IO String
getChars 0 = return []
getChars n = pure (:) <*> getChar <*> getChars (n-1)
```

### Applicative Laws

```hs
pure id <*> x   = x
pure (g x)      = pure g <*> pure x
x <*> pure y    = pure (\g -> g y) <*> x
x <*> (y <*> z) = (pure (.) <*> x <*> y) <*> z
```

All the applicative functors that we defined in the examples section satisfythe above laws. Moreover, each of these instances also satisfies the equation `fmap g x = pure g <*> x`, which shows how fmap can be defined in terms ofthe two applicative primitives. In fact, this latter law comes for free, by virtueof the fact that (as noted at the end of section 12.1) there is only one way tomake any given parameterised type into a functor, and hence any function withthe same polymorphic type as fmap must be equal to fmap.

> We conclude by noting that Haskell also provides an infix version of fmap, defined by `g <$> x = fmap g x`.

> applicative programming is about applying pure functions to effectful arguments.

## Monads

```hs
eval :: Expr -> Maybe Int
eval (Val n) = Just n
eval (Div x y) = case eval x of
                    Nothing -> Nothing
                    Just n -> case eval y of
                                 Nothing -> Nothing
                                 Just m -> safediv n m
```

Using this

```hs
(>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
mx >>= f = case mx of
              Nothing -> Nothing
              Just x -> f x
```

We can simplify the original block with:

```hs
eval :: Expr -> Maybe Int
eval (Val n) = Just n
eval (Div x y) = eval x >>= \n ->
                 eval y >>= \m ->
                 safediv n m
```

Expressions of the above form generalize to:

```hs
m1 >>= \x1 ->
m2 >>= \x2 ->
.
.
.
mn >>= \xn ->
f x1 x2 ... xn
```

But Haskell offers an even simpler manner of using them:

```hs
do x1 <- m1
   x2 <- m2
   .
   .
   .
   xn <- mn
   f x1 x2 ... xn
```

```hs
eval :: Expr -> Maybe Int
eval (Val n) = Just n
eval (Div x y) = do n <- eval x
                    m <- eval y
                    safediv n m
```

More generally, the do notation is not specific to the types IO and Maybe, but can be used with any applicative type that forms a monad. In Haskell, the concept of a monad is captured by the following built-in declaration:

```hs
class Applicative m => Monad m where
   return :: a -> m a
   (>>=) :: m a -> (a -> m b) -> m b

   return = pure
```

So a monad is:

- An applicative type `m`
- That supports
   - `return`
   - `>>=` of the specified types

### Examples

Lists can be turned into monads:

```hs
instance Monad [] where
   -- (>>=) :: [a] -> (a -> [b]) -> [b]
   xs >>= f = [y | x <- xs, y <- f x]

-- Now we can:
pairs :: [a] -> [b] -> [(a,b)]
pairs xs ys = do x <- xs
                 y <- ys
                 return (x,y)
```

### Monad Derivation

See file `12.hs` for the derivation of monads and an example with trees.

### Generic Functions

Generic functions for Monads can be found in `Control.Monad`:

```hs
mapM :: Monad m => (a -> m b) -> [a] -> m [b]
mapM f []     = return []
mapM f (x:xs) = do y <- f x
                   ys <- mapM f xs
                   return (y:ys)
```

### Monad Laws

```hs
return x >>= f   = f x
mx >>= return    = mx
(mx >>= f) >>= g = mx >>= (\x -> (f x >>= g))
```

Together, these two equations state, modulo the fact that the second argument to >>= involves a binding operation, that return is the identity for the >>= operator.


