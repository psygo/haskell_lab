# Defining Functions

## Conditional Expressions

There are many ways of creating conditional expressions:

- `abs n = if n >= 0 then n else -n`
    - You can nest `if`s to get the effect of if-else's.
    - Note that unlike in some programming languages, conditional expressions in Haskell must always have an else branch, which avoids the well-known dangling else problem. 
- Another way of doing it: *guarded equations*:
    ```hs
    abs n | n >= 0    = n
          | otherwise = -n
    ```
    - The symbol `|` is read as *such that*.
    - The guard otherwise is defined in thestandard prelude simply by `otherwise = True`.
- Another way of dealing with conditional expressions is through *pattern matching*.
    - This version also has the benefit that, under lazy evaluation as discussed in chapter 15, if the first argument is `False`, then the result `False` is returned without the need to evaluate the second argument.
- *Tuple Patterns*
- *List Patterns*
    - Up to this point, we have viewed lists as a primitive notion in Haskell. In fact they are not primitive as such, but are constructed one element at a time starting from the empty list [] using an operator : called cons that cons tructs a new list by prepending a new element to the start of an existing list. (`1:2:[] == [1,2]`)
    - Note that cons patterns must be parenthesised, because function applicationhas higher priority than all other operators in the language.

> Note that Haskell does not permit the same name to be used for more than one argument in a single equation. **Use guards to get around it.
```hs
b && c | b == c    = b
       | otherwise = False
```
## Lambda Expressions

As well as being interesting in their own right, lambda expressions have a number of practical applications. First of all, they can be used to formalise the meaning of curried function definitions.

```hs
add :: Int -> (Int -> Int)
add = \x -> (\y -> x + y)
```

Moreover, rewriting the original definition in this manner also has the benefit
that the type for the function and the manner in which it is defined now have
the same syntactic form, namely `? -> (? -> ?)`.

Secondly, lambda expressions are also useful when defining functions that re-
turn functions as results by their very nature, rather than as a consequence of
currying. For example, the library function const that returns a constant func-
tion that always produces a given value can be defined as follows:

```hs
const :: a -> (b -> a)
const x = \_ -> x
```


